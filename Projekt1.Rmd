---
title: "CompStat 1"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# A


```{r A1}
# Generate samples from exponential distribution
rate <- 3 #Rate parameter
n <- 1000 #Number of samples
generate.exponential <- function(rate, n){
  u <- runif(n)
  x <- - 1/rate * log(u)
  return(x)
}
x <- generate.exponential(rate, n)
hist(x, density=20, breaks = 30, prob=TRUE)
curve(dexp(x, rate=rate), add=TRUE, col="darkblue", lwd=2)
```

```{r A2}
# Generate samples from g(X)
rate <- 3 #Rate parameter
n <- 100 #Number of samples
generate.samples.g<- function(alpha, n){
  c <- alpha*exp(1)/(alpha+exp(1))
  u <- runif(n, 0,1)
  for (i in 1:n){
    if (u < c/(alpha)){
      x <- (u*(alpha)/c)^(1/alpha)
    }
    else{
      x <- 1-log(exp(1)/c*(1-u))
    }
    
  }
  return(x)
}
x <- generate.samples.g(0.1, n)
hist(x, density=20, breaks = 30, prob=TRUE)
```


```{r A3}
# Generate samples from normal distribution with Box-Muller
n <- 10000 #Number of samples
generate.normal <- function(n){
  u1 <- runif(n)
  u2 <- runif(n)
  x1 <- sqrt(-2*log(u1))*cos(2*pi*u2)
  x2 <- sqrt(-2*log(u1))*sin(2*pi*u2)
  X <- rbind(x1, x2)
  return (X)
}
X <- generate.normal(n)
hist(X[1,], density=20, breaks = 30, prob=TRUE)
curve(dnorm, add=TRUE, col="darkblue", lwd=2)
hist(X[2,], density=20, breaks = 30, prob=TRUE)
curve(dnorm, add=TRUE, col="darkblue", lwd=2)
print("Observed: ")
mean(X)
cov(t(X))
```

```{r A4}
# Generate n samples from d variate normal distribution
n <- 10000 #Number of samples
mu <- c(0,0)
sigma <- cbind(c(1,0.5),c(0.5,1))
generate.d.normal <- function(n, mu, sigma){
  A <- chol(sigma)
  d <- length(mu)
  X <- generate.normal(n*d)
  x <- matrix(X[1,], nrow=d, ncol=n)
  Z <- mu+t(A)%*%x
}
Z <- generate.d.normal(n, mu, sigma)
print("Expected: ")
mu
sigma
print('Observed: ')
mean(Z)
cov(t(Z))
```

# B

```{r B1}
#Function f(x)
function.f <- function(x, alpha){
  if (x>0){
    return (x^(alpha-1)*exp(-x)/gamma(alpha))
  }
  else{
    return(0)
  }
}

#Function g(x)
function.g <- function(x, alpha){
  c = alpha*exp(1)/(alpha+exp(1))
  if (x>0 && x<1){
    return (c*x^(alpha-1))
  }
  else if(x >= 1){
    return(c*exp(-x))
  }
  else{
    return(0)
  }
}

# Generate n samples from d variate normal distribution
n <- 1000 #Number of samples
alpha <- 0.3
rejection.sampling <- function(n, alpha){
  c <- (alpha+exp(1))/(gamma(alpha)*alpha*exp(1))
  samples <- c()
  for (i in 1:n){
    repeat{
      x <- generate.samples.g(alpha, 1)
      acceptance.prob <- function.f(x, alpha)/(c*function.g(x, alpha))
      if(runif(1) <= acceptance.prob){
        samples <- c(samples, x)
        break
      }
    }
  }
  return (samples)
}
y <- rejection.sampling(n, alpha)
print("Expected: ")
cat("Mean: ", alpha, "\n")
cat("Variance: ", alpha, "\n")
print("Observed: ")
cat("Mean: ", mean(y), "\n")
cat("Variance: ", var(y), "\n")
```

```{r B2}
log.gamma <- function(x, alpha){
  return((alpha-1)*log(x)-x)
}
# Ratio-of-uniforms method
n <- 1000
alpha <- 30
ratio.of.uniforms <- function(n, alpha){
  reject_counter <- -n
  b.minus <- 0
  log.b.plus <- (alpha+1)/2*(log(alpha+1)-1)
  log.a <- (alpha-1)/2*(log(alpha-1)-1)
  samples <- c()
  for(i in 1:n){
    repeat{
      reject_counter <- reject_counter + 1
      log.x1 <- -generate.exponential(1, rate=1) + log.a
      log.x2 <- -generate.exponential(1, rate=1) + log.b.plus
      log.y <- log.x2 - log.x1
      y <- exp(log.y)
      if (2*log.x1 <= log.gamma(y, alpha)){
        samples <- c(samples, y)
        break
      }
    }
  }
  cat("Rejection ratio: ", reject_counter/n , "\n")
  return (samples)
}
y <- ratio.of.uniforms(n, alpha)
print("Expected: ")
cat("Mean: ", alpha, "\n")
cat("Variance: ", alpha, "\n")
print("Observed: ")
cat("Mean: ", mean(y), "\n")
cat("Variance: ", var(y), "\n")
```

```{r B3}
n = 1000
alpha = 0.1
beta = 2
sample.gamma <- function(n, alpha, beta){
  if(alpha < 1){
    return(rejection.sampling(n, alpha)/beta)
  }
  else if (alpha == 1){
    return(generate.exponential(1, n)/beta)
  }
  else if (alpha > 1){
    return(ratio.of.uniforms(n, alpha)/beta)
  }
  else{
    return(0)
  }
}
y <- sample.gamma(n, alpha, beta)
print("Expected: ")
cat("Mean: ", alpha/beta, "\n")
cat("Variance: ", alpha/beta^2, "\n")
print("Observed: ")
cat("Mean: ", mean(y), "\n")
cat("Variance: ", var(y), "\n")
```

# D

```{r D1}
# Rejection sampling
n <- 200000 #Number weights to compute
m <- 10000 #Number of samples
multinomial.sampling <- function(n, theta){
  u <- runif(n)
  samples <- c(0, 0, 0, 0)
  y <- matrix(nrow=n, ncol=4, data=0)
  for (i in 1:n){
    if(u[i] < 1/2+theta[i]/4){
      samples[1] <- samples[1] + 1
      y[i, 1] <- y[i, 1] + 1 
    }
    else if(u[i] < 3/4){
      samples[2] <- samples[2] + 1
      y[i, 2] <- y[i, 2] + 1 
    }
    else if(u[i] < 1-theta[i]/4){
      samples[3] <- samples[3] + 1
       y[i, 3] <- y[i, 3] + 1 
    }
    else{
      samples[4] <- samples[4] + 1
      y[i, 4] <- y[i, 4] + 1 
    }
  }
  return (y)
}

f <- function(y, theta){
  return (2+theta)^y[1]*(1-theta)^(y[2]+y[3])*theta^y[4]
  
}
weighted.resampling <- function(n, m){
  theta <- runif(n)
  theta <- sort(theta)
  x <- multinomial.sampling(n, theta)
  weights <- c()
  for(i in 1:n){
    weights <- c(weights, f(x[i,],theta[i]))
  }
  weights <- weights/sum(weights)
  cumulative.weights <- cumsum(weights)
  samples <- c()
  for(i in 1:m){
    samples <- c(samples, theta[findInterval(runif(1), cumulative.weights)])
  }
  return (samples)
}
samples <- weighted.resampling(n, m)
hist(samples, density=20, breaks = 30, prob=TRUE)
mean(samples)

```

```{r D1.2}
# Rejection sampling
n <- 2000 #Number of samples
multinomial.sampling <- function(n, theta){
  u <- runif(n)
  samples <- c(0, 0, 0, 0)
  y <- 0
  return (y)
}

negative.f <- function(theta){
  y <- c(125, 18, 20, 34)
  return (-(2+theta)^y[1]*(1-theta)^(y[2]+y[3])*theta^y[4])
  
}
log.f <- function(theta){
  y <- c(125, 18, 20, 34)
  return (y[1]*log(2+theta)+(y[2]+y[3])*log(1-theta)+y[4]*log(theta))
}
rejection.sampling.2 <- function(n){
  theta.max <- optim(par=c(0.5), fn=negative.f)$par
  log.c <- log.f(theta.max)
  samples <- c()
  for(i in 1:n){
    repeat{
      theta <- runif(1)
      log.acceptance.prob <- log.f(theta)-log.c
      log.u <- -generate.exponential(1, rate=1)
      if (log.u <= log.acceptance.prob){
        samples <- c(samples, theta)
        break
      }
    }
  }
  return (samples)
}
samples <- rejection.sampling.2(n)
hist(samples, density=20, breaks = 30, prob=TRUE)
mean(samples)
```

```{r D2}
monte.carlo.integration <- function(){
  m <- 10000 # Number of samples
  samples <- rejection.sampling.2(m)
  mu <- sum(samples)/m
  return (mu)
}
theta.f <- function(theta){
  y <- c(125, 18, 20, 34)
  return (theta*(2+theta)^y[1]*(1-theta)^(y[2]+y[3])*theta^y[4])
}
print(monte.carlo.integration())
integrate(theta.f, lower=0, upper=1)
```